From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: BloodredX <bloodred.xhamster@gmail.com>
Date: Tue, 9 Nov 2021 13:53:53 -0500
Subject: [PATCH] Scatter Config and Command


diff --git a/build.gradle.kts b/build.gradle.kts
index 755a1afd0aa36b627b3c7327d6b88806498ba85b..035ea1e17a4fec2e94c5cee02cf7ffbe88fd4ecf 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -47,6 +47,13 @@ dependencies {
     runtimeOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.9.18")
     runtimeOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.9.18")
 
+    // Scatter start
+    implementation("org.yaml:snakeyaml:1.32")
+    implementation ("me.carleslc.Simple-YAML:Simple-Yaml:1.8.4") {
+        exclude(group="org.yaml", module="snakeyaml")
+    }
+    // Scatter end
+
     testImplementation("io.github.classgraph:classgraph:4.8.47") // Paper - mob goal test
     testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
     testImplementation("org.hamcrest:hamcrest:2.2")
diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 7620c72a4c243cbeea245203ce03a97cbfa7d922..b35a9f4c5f8960864c402ede8a51fb5ab9c4fcc0 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -240,7 +240,8 @@ public class TimingsExport extends Thread {
         parent.put("config", createObject(
             pair("spigot", mapAsJSON(Bukkit.spigot().getSpigotConfig(), null)),
             pair("bukkit", mapAsJSON(Bukkit.spigot().getBukkitConfig(), null)),
-            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null))
+            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null)), // Scatter
+            pair("scatter", mapAsJSON(in.bloodred.scatter.ScatterConfig.getConfigCopy(), null)) // Scatter
         ));
 
         new TimingsExport(listeners, parent, history).start();
diff --git a/src/main/java/in/bloodred/scatter/ScatterCommand.java b/src/main/java/in/bloodred/scatter/ScatterCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ca03dd3a8980c6cb4f38de5988855756f74f444
--- /dev/null
+++ b/src/main/java/in/bloodred/scatter/ScatterCommand.java
@@ -0,0 +1,68 @@
+package in.bloodred.scatter;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.md_5.bungee.api.ChatColor;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class ScatterCommand extends Command {
+
+    public ScatterCommand() {
+        super("scatter");
+        this.description = "Scatter related commands";
+        this.usageMessage = "/scatter [reload | version]";
+        this.setPermission("bukkit.command.scatter");
+    }
+    
+    public static void init() {
+        MinecraftServer.getServer().server.getCommandMap().register("scatter", "scatter", new ScatterCommand());
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("reload", "version")
+              .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+              .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        String prefix = ChatColor.of("#ffb7c5") + "" + ChatColor.BOLD + "Sakura Â» " + ChatColor.of("#448ee4");
+
+        if (args.length != 1) {
+            sender.sendMessage(prefix + "Usage: " + usageMessage);
+            args = new String[]{"version"};
+        }
+
+        if (args[0].equalsIgnoreCase("reload")) {
+            MinecraftServer console = MinecraftServer.getServer();
+            try {
+                ScatterConfig.load();
+            } catch (IOException e) {
+                sender.sendMessage(Component.text("Failed to reload.", NamedTextColor.RED));
+                e.printStackTrace();
+                return true;
+            }
+            console.server.reloadCount++;
+
+            Command.broadcastCommandMessage(sender, prefix + "Scatter configuration has been reloaded.");
+        } else if (args[0].equalsIgnoreCase("version")) {
+            Command.broadcastCommandMessage(sender, prefix + "This server is running " + Bukkit.getName() + " version " + Bukkit.getVersion() + " (Implementing API version " + Bukkit.getBukkitVersion() + ")");
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/in/bloodred/scatter/ScatterConfig.java b/src/main/java/in/bloodred/scatter/ScatterConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..970a1b160ce462b28e3714936d6b6227643998c5
--- /dev/null
+++ b/src/main/java/in/bloodred/scatter/ScatterConfig.java
@@ -0,0 +1,170 @@
+package in.bloodred.scatter;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.List;
+import net.minecraft.server.MinecraftServer;
+import org.apache.logging.log4j.Level;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.MemoryConfiguration;
+import org.jetbrains.annotations.Nullable;
+import org.simpleyaml.configuration.comments.CommentType;
+import org.simpleyaml.configuration.file.YamlFile;
+import org.simpleyaml.exceptions.InvalidConfigurationException;
+
+public class ScatterConfig {
+	
+	private static final YamlFile config = new YamlFile();
+	private static int updates = 0;
+	
+	private static ConfigurationSection convertToBukkit(org.simpleyaml.configuration.ConfigurationSection section) {
+		ConfigurationSection newSection = new MemoryConfiguration();
+		for (String key : section.getKeys(false)) {
+			if (section.isConfigurationSection(key)) {
+				newSection.set(key, convertToBukkit(section.getConfigurationSection(key)));
+			} else {
+				newSection.set(key, section.get(key));
+			}
+		}
+		return newSection;
+	}
+	
+	public static ConfigurationSection getConfigCopy() {
+		return convertToBukkit(config);
+	}
+	
+	public static int getUpdates() {
+		return updates;
+	}
+	
+	public static void load() throws IOException {
+		File configFile = new File("scatter.yml");
+		
+		if (configFile.exists()) {
+			try {
+				config.load(configFile);
+			} catch (InvalidConfigurationException e) {
+				throw new IOException(e);
+			}
+		}
+		
+		getString("info.version", "1.0");
+		setComment("info",
+				"Scatter Configuration",
+				"If you face any error, https://github.com/BloodredX/Scatter/issues",
+				"Join our Discord for support: https://dsc.gg/kmds",
+				"Download new builds at https://github.com/BloodredX/Scatter");
+		
+		for (Method method : ScatterConfig.class.getDeclaredMethods()) {
+			if (Modifier.isStatic(method.getModifiers()) && Modifier.isPrivate(method.getModifiers()) && method.getParameterCount() == 0 &&
+					method.getReturnType() == Void.TYPE && !method.getName().startsWith("lambda")) {
+				method.setAccessible(true);
+				try {
+					method.invoke(null);
+				} catch (Throwable t) {
+					MinecraftServer.LOGGER.warn("Failed to load configuration option from " + method.getName(), t);
+				}
+			}
+		}
+		
+		updates++;
+		
+		config.save(configFile);
+	}
+	
+	private static void setComment(String key, String... comment) {
+		if (config.contains(key)) {
+			config.setComment(key, String.join("\n", comment), CommentType.BLOCK);
+		}
+	}
+	
+	private static void ensureDefault(String key, Object defaultValue, String... comment) {
+		if (!config.contains(key)) {
+			config.set(key, defaultValue);
+			config.setComment(key, String.join("\n", comment), CommentType.BLOCK);
+		}
+	}
+	
+	private static boolean getBoolean(String key, boolean defaultValue, String... comment) {
+		return getBoolean(key, null, defaultValue, comment);
+	}
+	
+	private static boolean getBoolean(String key, @Nullable String oldKey, boolean defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getBoolean(key, defaultValue);
+	}
+	
+	private static int getInt(String key, int defaultValue, String... comment) {
+		return getInt(key, null, defaultValue, comment);
+	}
+	
+	private static int getInt(String key, @Nullable String oldKey, int defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getInt(key, defaultValue);
+	}
+	
+	private static double getDouble(String key, double defaultValue, String... comment) {
+		return getDouble(key, null, defaultValue, comment);
+	}
+	
+	private static double getDouble(String key, @Nullable String oldKey, double defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getDouble(key, defaultValue);
+	}
+	
+	private static String getString(String key, String defaultValue, String... comment) {
+		return getOldString(key, null, defaultValue, comment);
+	}
+	
+	private static String getOldString(String key, @Nullable String oldKey, String defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getString(key, defaultValue);
+	}
+	
+	private static List<String> getStringList(String key, List<String> defaultValue, String... comment) {
+		return getStringList(key, null, defaultValue, comment);
+	}
+	
+	private static List<String> getStringList(String key, @Nullable String oldKey, List<String> defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getStringList(key);
+	}
+ 	
+	public static String sentryDsn;
+	private static void sentry() {
+		String sentryEnvironment = System.getenv("SENTRY_DSN");
+		String sentryConfig = getString("sentry-dsn", "", "Sentry DSN for improved error logging, leave blank to disable", "Obtain from https://sentry.io/");
+		
+		sentryDsn = sentryEnvironment == null ? sentryConfig : sentryEnvironment;
+		if (sentryDsn != null && !sentryDsn.isBlank()) {
+			in.bloodred.scatter.sentry.SentryManager.init();
+		}
+	}
+
+	public static boolean tpsCatchup;
+	private static void tpsCatchup() {
+		tpsCatchup = getBoolean("performance.tps-catchup", true,
+				"If this setting is true,",
+				"The server will run faster after a lag spike inan attempt to maintain 20 TPS.",
+				"This option (defaults to true per spigot/paper) can cause mobs to move fast after a lag spike.");
+	}
+ 	
+	public static boolean enableBiomeManagerOptimization;
+	private static void biomeManagerOptimization() {
+		enableBiomeManagerOptimization = getBoolean("performance.optimize-biome-manager", true,
+				"This introduces efficient biome calculation logic.",
+				"It reduces server load by skipping unnecessary biome calculations.",
+				"This also boosts performance using pre-computed offsets.");
+	}
+ 	
+	public static String regionFormatTypeName;
+	public static int linearCompressionLevel;
+	public static boolean throwOnUnknownExtension;
+	public static int linearFlushFrequency;
+	private static void regionFormatVoid() {
+		regionFormatTypeName = getString("region-format-settings.format", "MCA","Available region formats: MCA, LINEAR");
+		linearCompressionLevel = getInt("region-format-settings.linear-compress-level", 1);
+		throwOnUnknownExtension = getBoolean("region-format-settings.throw-on-unknown-extension-detected", false);
+		regionFormatTypeName = getInt("region-format-settings.flush-interval-seconds", 5);
+  setComment("region-format-settings", "Linear is a region file format that uses ZSTD compression instead of ZLIB.", "This format saves about 50% of disk space.", "Read Documentation before using: https://github.com/xymb-endcrystalme/LinearRegionFileFormatTools", "Disclaimer: This is an experimental feature, there is potential risk to lose chunk data.", "So backup your server before switching to Linear.");
+	}
+ 
+ 	
+	public static boolean enableSuffocationOptimization;
+	private static void suffocationOptimization() {
+		enableSuffocationOptimization = getBoolean("performance.optimize-suffocation", true,
+				"Optimizes the suffocation check by selectively skipping the check in a way that still appears vanilla.",
+				"This should be left enabled on most servers,",
+				"but is provided as a configuration option if the vanilla deviation is undesirable.");
+    }
+	
+ }
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index dd56c8e041116ef3602a9f89c998c8208ab89b51..fb57a87d3d1e77da8fa2fba5298f7f651a0c83e0 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -239,6 +239,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
+        in.bloodred.scatter.ScatterConfig.load(); // Scatter
+        in.bloodred.scatter.ScatterCommand.init(); // Scatter
 
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
