From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: DenaryDev <denaryplanet@gmail.com>
Date: Fri, 3 Dec 2021 23:29:13 +0500
Subject: [PATCH] Sakura Entity Collisions Settings


diff --git a/src/main/java/in/bloodred/sakura/EntityFilter.java b/src/main/java/in/bloodred/sakura/EntityFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..f425005ac93ab78f967b65bee14f727835ba9787
--- /dev/null
+++ b/src/main/java/in/bloodred/sakura/EntityFilter.java
@@ -0,0 +1,118 @@
+package in.bloodred.sakura;
+
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntitySelector;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.MobCategory;
+import net.minecraft.world.scores.Team;
+
+import java.util.function.Predicate;
+
+public class EntityFilter {
+
+    public static Predicate<Entity> pushable(final Entity entity, final boolean ignoreClimbing) {
+        if (SakuraConfig.allCollisionsEnabled) {
+            return EntitySelector.pushable(entity, ignoreClimbing);
+        }
+
+        final Team entityTeam = entity.getTeam();
+        final Team.CollisionRule entityCollision = entityTeam == null ?
+            Team.CollisionRule.ALWAYS : entityTeam.getCollisionRule();
+
+        if (entityCollision == Team.CollisionRule.NEVER || entity.level().isClientSide || entity.isSpectator()) {
+            return tested -> false;
+        }
+
+        final Predicate<Entity> ret = (tested) -> {
+            if (!tested.isCollidable(ignoreClimbing) || !tested.canCollideWith(entity) || !entity.canCollideWith(tested)) {
+                return false;
+            }
+
+            Team testedTeam = tested.getTeam();
+            Team.CollisionRule testedCollision = testedTeam == null ?
+                Team.CollisionRule.ALWAYS : testedTeam.getCollisionRule();
+
+            if (testedCollision == Team.CollisionRule.NEVER) {
+                return false;
+            }
+
+            if (testedTeam != null && entityTeam != null) {
+                boolean allied = entityTeam.isAlliedTo(testedTeam);
+
+                if ((entityCollision == Team.CollisionRule.PUSH_OWN_TEAM || testedCollision == Team.CollisionRule.PUSH_OWN_TEAM) && allied) {
+                    return false;
+                }
+
+                return (entityCollision != Team.CollisionRule.PUSH_OTHER_TEAMS && testedCollision != Team.CollisionRule.PUSH_OTHER_TEAMS) || allied;
+            } else {
+                return entityCollision == Team.CollisionRule.ALWAYS && testedCollision == Team.CollisionRule.ALWAYS;
+            }
+        };
+
+        return ret.and((tested) -> {
+            if (tested.getType() == EntityType.PLAYER && SakuraConfig.playerCollisions) {
+                return true;
+            }
+            if (tested.getType().getCategory() == MobCategory.CREATURE && SakuraConfig.animalCollisions) {
+                return true;
+            }
+            if (tested.getType().getCategory() == MobCategory.AMBIENT && SakuraConfig.ambientCollisions) {
+                return true;
+            }
+            if (tested.getType().getCategory() == MobCategory.MONSTER) {
+                if (SakuraConfig.monsterCollisions) {
+                    if (SakuraConfig.pillagerCollisions) {
+                        return true;
+                    } else {
+                        return tested.getType() != EntityType.PILLAGER;
+                    }
+                } else {
+                    if (SakuraConfig.pillagerCollisions) {
+                        return tested.getType() == EntityType.PILLAGER;
+                    } else {
+                        return false;
+                    }
+                }
+            }
+            if (tested.getType().getCategory() == MobCategory.MISC) {
+                if (SakuraConfig.miscCollisions) {
+                    if (SakuraConfig.villagerCollisions && SakuraConfig.ironGolemCollisions && SakuraConfig.itemCollisions) {
+                        return true;
+                    }
+                    if (!SakuraConfig.villagerCollisions) {
+                        if (tested.getType() == EntityType.VILLAGER) {
+                            return false;
+                        }
+                    }
+                    if (!SakuraConfig.ironGolemCollisions) {
+                        if (tested.getType() == EntityType.IRON_GOLEM) {
+                            return false;
+                        }
+                    }
+                    if (!SakuraConfig.itemCollisions) {
+                        return tested.getType() != EntityType.ITEM;
+                    }
+                    return true;
+                } else {
+                    if (tested.getType() == EntityType.VILLAGER && SakuraConfig.villagerCollisions) {
+                        return true;
+                    }
+                    if (tested.getType() == EntityType.IRON_GOLEM && SakuraConfig.ironGolemCollisions) {
+                        return true;
+                    }
+                    return tested.getType() == EntityType.ITEM && SakuraConfig.itemCollisions;
+                }
+            }
+            if (tested.getType().getCategory() == MobCategory.WATER_AMBIENT && SakuraConfig.waterAmbientCollisions) {
+                return true;
+            }
+            if (tested.getType().getCategory() == MobCategory.WATER_CREATURE && SakuraConfig.waterCreatureCillisions) {
+                return true;
+            }
+            if (tested.getType().getCategory() == MobCategory.UNDERGROUND_WATER_CREATURE && SakuraConfig.undergroundWaterCreatureCollisions) {
+                return true;
+            }
+            return tested.getType().getCategory() == MobCategory.AXOLOTLS && SakuraConfig.axolotlCollisions;
+        });
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index cb03e9210eeb80cefbfe812d181edbdbc73055bc..265f55f4281a0b71a69cdbe7083bbf32a12ccff0 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3719,7 +3719,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
                 return;
             }
             // Paper end - don't run getEntities if we're not going to use its result
-            List<Entity> list = this.level().getEntities((Entity) this, this.getBoundingBox(), EntitySelector.pushable(this, this.level().paperConfig().collisions.fixClimbingBypassingCrammingRule)); // Paper - Climbing should not bypass cramming gamerule
+            List<Entity> list = this.level().getEntities((Entity) this, this.getBoundingBox(), in.bloodred.sakura.EntityFilter.pushable(this, this.level().paperConfig().collisions.fixClimbingBypassingCrammingRule)); // Paper - Climbing should not bypass cramming gamerule // Sakura - per entity type collision settings
 
             if (!list.isEmpty()) {
                 // Paper - don't run getEntities if we're not going to use its result; moved up
